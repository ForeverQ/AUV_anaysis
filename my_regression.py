from sklearn.linear_model import LinearRegression
import numpy as np

# All constant used in this module
RSQ_THRESHOLD_LINEAR = 0.99
RSQ_THRESHOLD_POLY = 0.99
MIXED_MODE_STATUS = True
INTERVAL_UNIT_NUM = 16

class PolynomialRegressionInterval(object):
    """implements a way to realize the interval regression

    This class implements some methods associated with interval regression. Solves the problems of fitting, predicting,
    and calculating derivatives under interval regression

    Attributes:
        linear_reg_funcs_: A list of tuples including regression functions and
                           marks of either 'linear' or 'polynomial'
        linear_reg_derivatives_: A list of tuples including derivative coefficients and
                                 marks of 'linear' or 'polynomial'
        intervals_: A list of values which identifies the subscript of borders of intervals
        interval_values_quad_: A list of values of polynomials according to the borders of intervals
    """

    def __init__(self):
        self.linear_reg_funcs_ = []
        self.linear_reg_derivatives_ = []
        self.intervals_ = []
        self.interval_values_quad_ = []

    def fit(self, X_quad, y, rsq_threshold_poly=RSQ_THRESHOLD_POLY,
            rsq_threshold_linear=RSQ_THRESHOLD_LINEAR,  mixed_mode=MIXED_MODE_STATUS):
        """Fits the data points and creates different intervals.

        Creates intervals by Dichotomy with the threshold of r^2.
        Mixes both the linear regression and polynomial regression.

        Args:
            X_quad: A list of values of polynomials generated by timestamp as x
            y: A list of values of values as y
            rsq_threshold_poly: A threshold value for polynomial regression
            rsq_threshold_linear: A threshold value for linear regression
            mixed_mode: If the fitting mixed with linear and poly. or only poly.

        Returns:
            Returns an instance of self.
        """
        self.X_quad_when_fitting = X_quad

        # use a kind of small interval unit to force the fitting accurate
        interval_unit_num = len(self.X_quad_when_fitting) // INTERVAL_UNIT_NUM
        sub_start = 0
        sub_end = sub_start + interval_unit_num
        while sub_start < len(self.X_quad_when_fitting):
            r_square_poly = 0
            reg_func_poly = LinearRegression()
            has_been_in_while = False
            if mixed_mode:
                r_square_linear = 0
                reg_func_linear = LinearRegression()
                while r_square_linear < rsq_threshold_linear and r_square_poly < rsq_threshold_poly:
                    if has_been_in_while:
                        sub_end = (sub_end - sub_start) // 2 + sub_start
                    now_X_poly = self.X_quad_when_fitting[sub_start:sub_end]
                    now_X_linear = np.array([*map(lambda a:[a[1]], now_X_poly)])
                    now_y = y[sub_start:sub_end]
                    reg_func_poly = LinearRegression()
                    reg_func_linear = LinearRegression()
                    reg_func_poly.fit(now_X_poly, now_y)
                    reg_func_linear.fit(now_X_linear, now_y)
                    r_square_poly = reg_func_poly.score(now_X_poly, now_y)
                    r_square_linear = reg_func_linear.score(now_X_linear, now_y)
                    has_been_in_while = True
                    if r_square_linear == 0:
                        r_square_linear = 1.0
                    elif r_square_poly == 0:
                        r_square_poly = 1.0
                self.intervals_.append(sub_end)
                self.interval_values_quad_.append(self.X_quad_when_fitting[sub_end - 1])
                if r_square_linear >= rsq_threshold_linear:
                    self.linear_reg_funcs_.append((reg_func_linear,'linear'))

                    # for debug
                    # print('linear_r2: ' + str(r_square_linear))
                else:
                    self.linear_reg_funcs_.append((reg_func_poly,'poly'))

                    # for debug
                    # print('poly_r2: ' + str(r_square_poly))
                sub_start = sub_end
                sub_end = min(sub_start+interval_unit_num, len(self.X_quad_when_fitting))
            else:
                while r_square_poly < rsq_threshold_poly:
                    if has_been_in_while:
                        sub_end = (sub_end - sub_start) // 2 + sub_start
                    now_X_poly = self.X_quad_when_fitting[sub_start:sub_end]
                    now_y = y[sub_start:sub_end]
                    reg_func_poly = LinearRegression()
                    reg_func_poly.fit(now_X_poly, now_y)
                    r_square_poly = reg_func_poly.score(now_X_poly, now_y)
                    has_been_in_while = True
                    if r_square_poly == 0:
                        r_square_poly = 1.0
                self.intervals_.append(sub_end)
                self.interval_values_quad_.append(self.X_quad_when_fitting[sub_end - 1])
                self.linear_reg_funcs_.append((reg_func_poly,'poly'))
                sub_start = sub_end
                sub_end = min(sub_start+interval_unit_num, len(self.X_quad_when_fitting))

        # for debug
        # print()
        return self

    def predict(self, X_quad):
        """Predicts values by the funcs. fitted before

        Aims to get a list of y values calculated by the functions.
        Each y value corresponds to each X value.
        Mainly solves the problem of deciding which interval's function to use by corresponding range of X values.

        Args:
            X_quad: A list of X values used to calculate function y

        Returns:
            A list of y values (predicted values), shape of which is the same as that of X values
        """
        y = []
        reg_func_interval_num = 0
        interval_right_value = self.X_quad_when_fitting[self.intervals_[reg_func_interval_num]-1][1]
        X_quad_left_index = 0
        value_of_X = X_quad[0][1]
        while not (value_of_X <= interval_right_value):
            reg_func_interval_num += 1
            interval_right_value = self.X_quad_when_fitting[self.intervals_[reg_func_interval_num]-1][1]
        for index, one_X in enumerate(X_quad):

           # get one-power value of X from X_quad
            value_of_X = one_X[1]
            if (index == len(X_quad)-1):
                now_X_quad = X_quad[X_quad_left_index:index+1]
                now_func = self.linear_reg_funcs_[reg_func_interval_num][0]
                if self.linear_reg_funcs_[reg_func_interval_num][1]=='linear':
                    now_X_linear = np.array([*map(lambda a:[a[1]],now_X_quad)])
                    sub_y = now_func.predict(now_X_linear)
                else:
                    sub_y = now_func.predict(now_X_quad)
                y += list(sub_y)
            elif (value_of_X > interval_right_value):
                now_X_quad = X_quad[X_quad_left_index:index]
                if self.linear_reg_funcs_[reg_func_interval_num][1]=='linear':
                    now_X_linear = np.array([*map(lambda a:[a[1]],now_X_quad)])
                    sub_y = self.linear_reg_funcs_[reg_func_interval_num][0].predict(now_X_linear)
                else:
                    sub_y = self.linear_reg_funcs_[reg_func_interval_num][0].predict(now_X_quad)
                y += list(sub_y)
                X_quad_left_index = index
                reg_func_interval_num += 1
                interval_right_value = self.X_quad_when_fitting[self.intervals_[reg_func_interval_num]-1][1]
        return np.array(y)

    def calculate_derivatives(self):
        """Calculates the derivatives of functions of different intervals"""
        def my_derivative_poly(coef_):
            coef = []
            for i in range(1, len(coef_)):
                coef.append(i*coef_[i])
            return np.array(coef)
        for func_tuple in self.linear_reg_funcs_:
            if func_tuple[1] == 'linear':
                coef_d = np.array([func_tuple[0].coef_[0]])
                self.linear_reg_derivatives_.append((coef_d, 'linear'))
            else:
                coef_d = my_derivative_poly(func_tuple[0].coef_)
                self.linear_reg_derivatives_.append((coef_d, 'poly'))

    def predict_d(self, X_quad_d):
        """Predicts y values for functions of derivatives.
           The values are calculated by vector multiplication.
           Also returns a list of y values shape of which is the same as that of X values.
        """
        if len(self.linear_reg_derivatives_) == 0:
            self.calculate_derivatives()
        y_d = []
        reg_func_interval_num = 0

        # get one-power value of X from X_quad
        interval_right_value = self.X_quad_when_fitting[self.intervals_[reg_func_interval_num]-1][1]
        X_quad_left_index = 0
        is_in_range = False
        for index, one_X_d in enumerate(X_quad_d):

            # get one-power value of X from X_quad
            value_of_X_d = one_X_d[1]
            if value_of_X_d < interval_right_value:
                is_in_range = True
            if is_in_range:
                if (value_of_X_d > interval_right_value):
                    if (index != len(X_quad_d)-1):
                        now_X_quad = X_quad_d[X_quad_left_index:index]
                        sub_coef_d = self.linear_reg_derivatives_[reg_func_interval_num][0]
                        if self.linear_reg_derivatives_[reg_func_interval_num][1] == 'linear':
                            sub_y_d = len(now_X_quad)*list(sub_coef_d)
                        else:
                            sub_y_d = now_X_quad.dot(sub_coef_d)
                        y_d += list(sub_y_d)
                        X_quad_left_index = index
                        reg_func_interval_num += 1
                        interval_right_value = self.X_quad_when_fitting[self.intervals_[reg_func_interval_num]-1][1]
                    else:
                        now_X_quad = X_quad_d[X_quad_left_index:index+1]
                        sub_coef_d = self.linear_reg_derivatives_[reg_func_interval_num][0]
                        if self.linear_reg_derivatives_[reg_func_interval_num][1] == 'linear':
                            sub_y_d = len(now_X_quad)*list(sub_coef_d)
                        else:
                            sub_y_d = now_X_quad.dot(sub_coef_d)
                        y_d += list(sub_y_d)
                elif (index == len(X_quad_d)-1):
                    now_X_quad = X_quad_d[X_quad_left_index:index+1]
                    sub_coef_d = self.linear_reg_derivatives_[reg_func_interval_num][0]
                    if self.linear_reg_derivatives_[reg_func_interval_num][1] == 'linear':
                        sub_y_d = len(now_X_quad)*list(sub_coef_d)
                    else:
                        sub_y_d = now_X_quad.dot(sub_coef_d)
                    y_d += list(sub_y_d)
            else:
                reg_func_interval_num += 1
                interval_right_value = self.X_quad_when_fitting[self.intervals_[reg_func_interval_num]-1][1]
        return np.array(y_d)
